[toc]
# 1. 引言
垃圾收集器主要关注的是堆和方法区中的垃圾收集。
# 2. 判断对象是否存活的依据
## 2.1 引用计数法
其方法是给对象添加一个引用计数器，每当有一个地方引用他时，计数器加1，当引用失效时，计数器值减1，但是这个方法存在一个问题就是互相引用时，计数器当值永远不为0。
## 2.2 可达性分析算法
通过一系列称为“GC Roots”的对象作为起始点，一个对象到GC Roots的路径称为“引用链”（Reference Chain）当一个对象到GC Roots不存在任何引用链时，就会判定他为可回收对象。
可作为GC Roots的对象包括：
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中引用的对象
# 3. 引用类型
引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种。  
- 强引用类似"Object obj = new Object()"，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用用来描述一些还有用但非必需的对象，对于软引用关联的对象，在系统发生内存溢出之前，会把这些对象列进回收范围进行二次回收，相关的类为SoftReference
- 弱引用用来描述非必需的对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，相关的类为WeakReference 
- 虚引用也称为幽灵引用或者幻影引用，是最弱的一种引用关系，相关类为PhantomReference。
# 4. 垃圾收集算法
此处不探讨实现细节，只是讲一下算法的思想
## 4.1 标记——清除(Mark-Sweep)算法
简而言之就是先标记需要回收的内存片段，然后回收。他有两点不足：首先是效率不高，其次是会产生大量不连续的内存碎片。
## 4.2 复制算法（新生代）
将内存容量划分为相等的两块，每次只使用其中一块，当使用完以后就将还存活的对象复制到另一块内存中并将原来的那块内存清除。有研究发现超过百分之90以上的新生代对象都是“朝生夕死”，所以没有必要1:1的划分为两块相等的内存区域，在HopSpot虚拟机中，Eden与两块Survivor的大小比例是8:1:1，每次回收时将Eden和一块Survivor中还存活的对象一次性复制到另一块Survivor空间中，这样只有10%的内存被“浪费”。
## 4.3 标记——整理算法（老年代）
在存活率较高的老年代并不适合使用复制算法，在老年代使用的垃圾收集策略是让所有存活的对象都在内存中向一端移动并靠拢，清后清除掉边界以外的内存。
## 4.4 分代收集算法
综上所述，根据不同的对象存活周期，将内存划分为好几块，在新生代中使用复制算法，在老年代中使用“标记-整理”或者“标记—清除”算法进行垃圾回收。
# 5. 垃圾收集器
每种垃圾收集器都有最适合的应用场景。
![垃圾收集器](https://raw.githubusercontent.com/little-motor/uml/master/Java/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)
<center>HotSpot虚拟机的垃圾收集器</center>
## 5.1 Serial收集器
他是最悠久的收集器，一种单线程收集器，同时在垃圾收集时会暂停所有的工作线程，直到收集结束。他是Client模式下的默认新生代收集器。
## 5.2 ParNew收集器
ParNew收集器是Serial收集器的多线程版本，同时能够与CMS（Concurrent Mark Sweep），ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后默认新生代收集器，也可以使用<code>-XX:+UseParNewGC</code>选项来强制使用他。
需要注意的是ParNew收集器由于线程切换的开销，所以在单核或者核心较少的情况下，对比Serial收集器并没有优势。可以使用<code>-XX:ParallelGCTHreads</code>参数来限制垃圾收集的线程数。

Column A | Column B | Column C
---------|----------|---------
 A1 | B1 | C1
 A2 | B2 | C2
 A3 | B3 | C3