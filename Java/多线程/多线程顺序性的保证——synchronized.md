[toc]
# 1. 引言
实现“顺序性”的主要方式就是加锁，synchronized与多种锁，此次内容主要讲讲synchronized在jdk1.6以后做的一些锁优化。
# 2. synchronized同步基础
Java中的每一个对象都可以作为锁，主要有以下三种：
1. 对于普通同步方法，锁是当前实例对象
2. 对于静态同步方法，锁是当前类的Class对象
3. 对与同步方法块，锁是Synchronized括号里配置的对象

当一个线程试图访问同步代码块时，他必须首先得到锁，推出或抛出异常时必须释放锁。synchronized在JVM里的实现原理是基于进入和退出Monitor对象来实现方法同步和代码块同步，monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。
# 3. Java对象头
synchronized用的锁是存在Java对象头里面的，如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于32bit。

长度| 内容 | 说明
---------|----------|---------
 32/64bit | Mark Word | 存储对象对hashCode或锁信息等
 32/64bit | Class Metadata Address | 存储到对象类型数据的指针
 32/64bit | Array length | 数组的长度（如果当前对象是数组）
# 4. 锁的升级与对比
Java SE 1.6为了优化锁的性能，增加了几种锁的状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这几种状态会随着竞争情况逐渐升级，锁的状态可以升级但不可以降级。
## 4.1 偏向锁
HotSpot作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。在无实际线程竞争，且将来只有一个线程申请锁时，偏向锁能最大限度提升性能，减少上下文切换以及线程阻塞过程中用户态和核心态切换造成对性能影响。
当一个线程访问同步块并获得锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时，不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
### 4.1.1 偏向锁的撤销
偏向锁使用一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁撤销需要等到全局安全点，然后检查持有偏向锁的线程是否处于活动状态，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
## 4.2 轻量级锁和重量级锁
### 4.2.1 轻量级锁加锁
线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
轻量级锁瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。如果锁的持有时间比较短，那么，对于竞争这些锁的线程而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：
当前线程竞争锁失败时，不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会，在自旋的同时重新竞争锁，如果自旋结束前获得了锁，那么锁获取成功；否则，自旋一定次数后会阻塞自己。如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己，减少了一次线程切换。
### 4.2.2 轻量级锁解锁
轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
因为自旋会消耗CPU，为了避免无用的自旋，一旦锁升级到重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程视图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。
# 5. 锁优缺点总结

 锁 |  优点 | 缺点 | 适用场景
---------|----------|---------|-------
 偏向锁 | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景
 轻量级锁 | 竞争的线程不会阻塞，提高了线程的响应速度 | 如果始终得不到锁，竞争过程中的自旋会消耗CPU | 追求响应时间，同步块执行速度非常快
 重量级锁 | 线程竞争不使用自旋，不会额外消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较长

