[toc]
# 1. 引言
多核CPU的兴起成为了不容回避的事实，但是涉及锁的编程算法不但容易出错，而且耗费时间，java.util.concurrent和第三方类库的效果也不是很好，Lambda表达式是为了支持多核CPU的高效并行运算而产生的。
面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象，同时函数式编程增加了代码的可读性，在写回调函数和事件处理程序时，程序员不必纠缠于内部类的冗繁和可读性，函数式编程让事件处理变得更加简单，能将函数方便的传递也让编写惰性代码变得容易，惰性代码在真正需要时才初始化变量的值。
**函数式编程的核心是：在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值**。
# 2. 第一个Lambda表达式
Java8引入了Lambda表达式是一种紧凑的、传递行为的方式。下面是一个Swing中的按钮监听器
```
button.addActionListener(new ActionListener(){
    public void actionPerformer(ActionEvent event){
        System.out.println("button clicked");
    }
})
```
设计匿名内部类的目的是为了方便Java程序员将代码作为数据传递，不过他还是不够简洁，里面加油冗繁的样板代码，而且还不易读，**我们不想传入对象，只想传入行为**。
使用Lambda表达式重构后的代码
```
button.addActionListener(event -> System.out.println("button clicked"));
```
和传入一个实现某接口的对象不同，我们传入了一个代码块——一个没有名字的函数。event是参数名和上面匿名内部类中的是同一个参数。->将参数和Lambda表达式的主体分开，而主体是用户点击按钮时会运行的一些代码。
另一处不同在于匿名内部类需要显式声明参数类型Actionevent event，而Lambda表达式无需指定类型，程序依然可以编译，这是因为在编译期间javac会推断出参数类型。（当然也可以加入参数类型，防止特殊情况无法推断出参数类型）
## 2.1 如何辨别Lambda表达式
除了基本形式之外还有几种变体
```
//（）表示没有参数，实现Runnable接口，该接口只有一个run方法，没有参数返回类型为void
Runnable noArguments = () -> System.out.println("hello world");

//只有一个参数可以省略括号
ActionListener oneArgument = event -> System.out.println("button clicked");

//Lambda表达式主体可以是一段代码块，用大括号括起来，代码块和普通方法相同，可以用返回或抛出异常来退出。
Runnable multiStatement = () -> {
    System.out.print("Hello");
    System.out.println(" World");
};

//主体并不是将两数相加，而是创建一个函数，用来计算结果。
//即add的类型是BinaryOperator<long>，他是将两个数字相加的那行代码
BinaryOperator<Long> add = (x,y) -> x + y;

BinaryOperator<Long> addExplicit = (Long x, Long y) -> x + y;
```