[toc]
## 1. 引言
动态代理的意义在于生成一个占位（又称代理对象），来代理真实对象，从而控制真实对象的访问，先来谈谈代理模式

![代理模式](https://raw.githubusercontent.com/little-motor/uml/master/proxyPattern.png)
<center>代理模式示意图</center>
代理的作用就是在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象，所以代理必须实现两个步骤：

- 代理对象和真实对象建立代理关系
- 实现代理对象的代理逻辑方法
Java中最常用的动态代理技术有JDK动态代理和CGLIB，JDK必须使用接口而CGLIB不需要。
## 2. JDK动态代理
### 2.1 定义接口
JDK动态代理是java.lang.reflect.*包提供的方式，他必须借助一个接口才能产生代理对象，所以先定义接口
```
/**
 * 使用jdk动态代理必须要使用接口
 * @author littlemotor
 *
 */
public interface HelloWorld {
  abstract public void sayHelloWorld();
}

```
### 2.2 实现类
```
public class HelloWorldImp implements HelloWorld{

  @Override
  public void sayHelloWorld() {
    System.out.println("Hello World!");
  }

}
```
### 2.3 动态代理绑定和代理逻辑实现
```
public class JdkProxy implements InvocationHandler{

  //真实对象
  private Object target = null;
  
  /**
   * 建立代理对象和真实对象的代理关系，并返回代理对象
   * @param target
   * @return 代理对象
   */
  public Object bind(Object target) {
    this.target = target;
    return Proxy.newProxyInstance(target.getClass().getClassLoader(),
        target.getClass().getInterfaces(), this);
  }
  
  /**
   *代理方法逻辑
   * @param proxy 代理对象
   * @param method 当前调度对象
   * @param args 当前方法参数
   * @return 代理结果返回
   * @throws Throwable
   */
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("进入代理逻辑方法");
    System.out.println("调用真实对象之前的服务");
    Object obj = method.invoke(target, args);
    System.out.println("调用真实对象之后的服务");
    return obj;
  }
}
```
JDK动态代理总共分为两大步：
- 建立代理对象和真实对象的关系
- 实现代理逻辑方法
### 2.4 建立代理对象和真实对象的关系
这里使用bind方法完成，方法里首先用类的属性target保存了真实对象，然后通过如下代码建立并生成代理对象
```
Proxy.newProxyInstance(target.getClass().getClassLoader(),
        target.getClass().getInterfaces(), this);
```
newProxyInstance方法包含三个参数
- 第1个是类加载器，我们采用target本身的类加载器
- 第2个是把生成的动态代理对象下挂到哪些接口下面
- 第3个是定义实现方法逻辑的代理类，这个this表示当前对象，他必须实现InvocationHandler接口的inoke方法
### 2.5 实现代理逻辑方法
invoke方法可以实现代理逻辑，invoke有三个参数含义如下：
- proxy，代理对象，就是bind方法生成的对象
- method，当天调度的方法
- args，调度方法的参数
```
Object obj = method.invoke(target,args);
```
### 2.6 main方法
```
public class JdkProxyMain {
  public static void main(String[] args) {
    JdkProxy jdkProxy = new JdkProxy();
    //System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
    HelloWorld helloWorld = (HelloWorld) jdkProxy.bind(new HelloWorldImp());
    helloWorld.sayHelloWorld();
  }
}

//进入代理逻辑方法
//调用真实对象之前的服务
//Hello World!
//调用真实对象之后的服务

```